<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LDS Training Impact Dashboard</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #f5f7fa;
            color: #2c3e50;
            line-height: 1.6;
        }

        .dashboard-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #0C2340 0%, #1a3a5c 50%, #0C2340 100%);
            color: white;
            padding: 35px;
            border-radius: 12px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(12, 35, 64, 0.3);
            position: relative;
        }

        h1 {
            font-size: 2em;
            margin-bottom: 5px;
            font-weight: 700;
        }

        .subtitle {
            font-size: 1.1em;
            opacity: 0.85;
        }

        .header-meta {
            font-size: 0.85em;
            opacity: 0.65;
            margin-top: 4px;
        }

        .header-actions {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            align-items: center;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .btn-primary {
            background: #C99700;
            color: white;
        }

        .btn-primary:hover {
            background: #b08600;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: white;
            color: #0C2340;
        }

        .btn-secondary:hover {
            background: #f0f0f0;
            transform: translateY(-2px);
        }

        .file-upload-area {
            display: none;
            background: rgba(255,255,255,0.1);
            border: 2px dashed rgba(255,255,255,0.5);
            border-radius: 8px;
            padding: 20px;
            margin-top: 15px;
            text-align: center;
        }

        .file-upload-area.active {
            display: block;
        }

        .file-upload-area input[type="file"] {
            display: none;
        }

        .upload-label {
            cursor: pointer;
            padding: 15px 30px;
            background: white;
            color: #0C2340;
            border-radius: 6px;
            display: inline-block;
            font-weight: 600;
            transition: background 0.3s;
        }

        .upload-label:hover {
            background: #f0f0f0;
        }

        .upload-status {
            margin-top: 10px;
            font-size: 0.9em;
        }

        .kpi-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .kpi-card {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border-top: 4px solid #0C2340;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .kpi-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }

        .kpi-card.nps-excellent { border-top-color: #28a745; }
        .kpi-card.nps-good { border-top-color: #C99700; }
        .kpi-card.nps-poor { border-top-color: #dc3545; }

        .kpi-label {
            font-size: 0.85em;
            color: #7f8c8d;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .kpi-value {
            font-size: 2.5em;
            font-weight: 700;
            color: #0C2340;
            line-height: 1;
        }

        .kpi-subtitle {
            font-size: 0.85em;
            color: #95a5a6;
            margin-top: 5px;
        }

        .kpi-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 600;
            margin-top: 8px;
        }

        .badge-excellent { background: #d4edda; color: #155724; }
        .badge-good { background: #fff3cd; color: #856404; }
        .badge-poor { background: #f8d7da; color: #721c24; }

        /* Key Takeaways */
        .takeaways-section {
            background: white;
            padding: 25px 30px;
            border-radius: 10px;
            margin-bottom: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            border-left: 5px solid #0C2340;
        }

        .takeaways-title {
            font-size: 1.3em;
            color: #0C2340;
            margin-bottom: 15px;
            font-weight: 700;
        }

        .takeaway-item {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 0.95em;
            color: #34495e;
        }

        .takeaway-icon {
            flex-shrink: 0;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
            margin-top: 2px;
        }

        .icon-green { background: #28a745; }
        .icon-gold { background: #C99700; }
        .icon-blue { background: #0C2340; }
        .icon-red { background: #dc3545; }

        .section {
            background: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 25px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        }

        .section-title {
            font-size: 1.4em;
            color: #0C2340;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e8ecef;
            font-weight: 600;
        }

        .chart-insight {
            margin-top: 15px;
            padding: 12px 16px;
            background: #f8f9fb;
            border-left: 3px solid #C99700;
            border-radius: 0 6px 6px 0;
            font-size: 0.9em;
            color: #4a5568;
            line-height: 1.6;
        }

        .chart-insight strong {
            color: #0C2340;
        }

        .filter-container {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
            align-items: center;
        }

        .filter-label {
            font-weight: 600;
            color: #2c3e50;
        }

        select {
            padding: 10px 15px;
            border: 2px solid #e0e6ed;
            border-radius: 6px;
            font-size: 1em;
            background: white;
            cursor: pointer;
            transition: border-color 0.2s;
            min-width: 200px;
        }

        select:hover {
            border-color: #0C2340;
        }

        select:focus {
            outline: none;
            border-color: #0C2340;
        }

        .chart-container {
            margin-top: 20px;
        }

        .grid-2col {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 25px;
        }

        .axis text {
            font-size: 12px;
            fill: #5a6c7d;
        }

        .axis line,
        .axis path {
            stroke: #d0d7de;
        }

        .gridline {
            stroke: #e8ecef;
            stroke-dasharray: 3,3;
        }

        .tooltip {
            position: absolute;
            background: rgba(12, 35, 64, 0.95);
            color: white;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1000;
        }

        .tooltip.show {
            opacity: 1;
        }

        .bar {
            transition: opacity 0.2s;
        }

        .bar:hover {
            opacity: 0.8;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .comment-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .comment-table th {
            background: #f8f9fa;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #0C2340;
            border-bottom: 2px solid #e0e6ed;
        }

        .comment-table td {
            padding: 12px;
            border-bottom: 1px solid #e8ecef;
        }

        .comment-table tr:nth-child(even) {
            background: #fafbfc;
        }

        .comment-table tr:hover {
            background: #f0f4f8;
        }

        .comment-text {
            max-width: 600px;
            line-height: 1.5;
        }

        .score-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.85em;
        }

        .score-high {
            background: #d4edda;
            color: #155724;
        }

        .score-mid {
            background: #fff3cd;
            color: #856404;
        }

        .score-low {
            background: #f8d7da;
            color: #721c24;
        }

        @media (max-width: 768px) {
            .grid-2col {
                grid-template-columns: 1fr;
            }

            .kpi-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <header>
            <h1>LDS Training Impact Dashboard</h1>
            <div class="subtitle">Leadership Development Series | Fall 2025 Evaluation Results</div>
            <div class="header-meta" id="header-meta"></div>
            <div class="header-actions">
                <button class="btn btn-primary" onclick="downloadExcel()">Download Excel Report</button>
                <button class="btn btn-secondary" onclick="toggleUpload()">Upload Updated Data</button>
            </div>
            <div class="file-upload-area" id="upload-area">
                <input type="file" id="file-input" accept=".xlsx,.csv" onchange="handleFileUpload(event)">
                <label for="file-input" class="upload-label">Choose File (Excel or CSV)</label>
                <div class="upload-status" id="upload-status"></div>
            </div>
        </header>

        <!-- KPI Cards -->
        <div class="kpi-container" id="kpi-container"></div>

        <!-- Key Takeaways -->
        <div class="takeaways-section" id="takeaways-section">
            <div class="takeaways-title">Key Takeaways</div>
            <div id="takeaways-content"></div>
        </div>

        <!-- Filters -->
        <div class="section">
            <div class="filter-container">
                <span class="filter-label">Filter by Training Session:</span>
                <select id="session-filter">
                    <option value="all">All Sessions</option>
                </select>
                <span class="filter-label">Filter by Department:</span>
                <select id="department-filter">
                    <option value="all">All Departments</option>
                </select>
            </div>
        </div>

        <!-- Session Comparison -->
        <div class="section">
            <h2 class="section-title">Training Session Comparison</h2>
            <div class="chart-container" id="session-comparison"></div>
            <div class="chart-insight" id="insight-session"></div>
        </div>

        <!-- Department and NPS Distribution -->
        <div class="grid-2col">
            <div class="section">
                <h2 class="section-title">Department Participation</h2>
                <div class="chart-container" id="department-chart"></div>
                <div class="chart-insight" id="insight-department"></div>
            </div>
            <div class="section">
                <h2 class="section-title" id="nps-title">NPS Score Distribution</h2>
                <div class="chart-container" id="nps-distribution"></div>
                <div class="chart-insight" id="insight-nps"></div>
            </div>
        </div>

        <!-- Satisfaction Metrics -->
        <div class="section">
            <h2 class="section-title">Satisfaction Metrics (Likert Scale Responses)</h2>
            <div class="chart-container" id="likert-chart"></div>
            <div class="chart-insight" id="insight-likert"></div>
        </div>

        <!-- Comments Section -->
        <div class="section">
            <h2 class="section-title">Participant Comments</h2>
            <div id="comments-container"></div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script>
        // Color palette
        const colors = {
            primary: '#0C2340',
            secondary: '#C99700',
            tertiary: '#AE9142',
            success: '#28a745',
            warning: '#ffc107',
            danger: '#dc3545',
            info: '#17a2b8',
            blue: '#4A90E2',
            purple: '#9B59B6',
            teal: '#1abc9c',
            orange: '#e67e22',
            likert: {
                'Agree': '#28a745',
                'Tend to agree': '#8BC34A',
                'Neither': '#FFC107',
                'Tend to disagree': '#FF9800',
                'Disagree': '#dc3545'
            }
        };

        let allData = [];
        let filteredData = [];

        // Toggle upload area
        function toggleUpload() {
            const uploadArea = document.getElementById('upload-area');
            uploadArea.classList.toggle('active');
        }

        // Download Excel file
        function downloadExcel() {
            window.location.href = 'LDS_Survey_Export_Editable.xlsx';
        }

        // NPS classification helper
        function npsLabel(nps) {
            if (nps >= 50) return { text: 'Excellent', cls: 'excellent' };
            if (nps >= 0) return { text: 'Good', cls: 'good' };
            return { text: 'Needs Improvement', cls: 'poor' };
        }

        // Handle file upload
        function handleFileUpload(event) {
            const file = event.target.files[0];
            const statusDiv = document.getElementById('upload-status');

            if (!file) {
                return;
            }

            statusDiv.textContent = 'Processing file...';
            statusDiv.style.color = '#FFC107';

            const reader = new FileReader();

            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, {type: 'array'});

                    const sheetName = workbook.SheetNames.find(name =>
                        name.includes('Survey Data') || name.includes('Editable')
                    ) || workbook.SheetNames[0];

                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, {
                        header: 1,
                        defval: null
                    });

                    let headerRowIndex = -1;
                    for (let i = 0; i < Math.min(10, jsonData.length); i++) {
                        const row = jsonData[i];
                        if (row && row.some(cell =>
                            cell && (cell.includes('Department') || cell.includes('Training Session'))
                        )) {
                            headerRowIndex = i;
                            break;
                        }
                    }

                    if (headerRowIndex === -1) {
                        throw new Error('Could not find header row in uploaded file');
                    }

                    const headers = jsonData[headerRowIndex];
                    const dataRows = jsonData.slice(headerRowIndex + 1);

                    const colMap = {};
                    headers.forEach((header, idx) => {
                        if (header) {
                            const cleanHeader = header.toString().trim().toLowerCase();
                            if (cleanHeader.includes('department')) colMap.department = idx;
                            if (cleanHeader.includes('training session')) colMap.session = idx;
                            if (cleanHeader.includes('content relevance')) colMap.q3_1 = idx;
                            if (cleanHeader.includes('duration')) colMap.q3_2 = idx;
                            if (cleanHeader.includes('usability')) colMap.q3_3 = idx;
                            if (cleanHeader.includes('training score')) colMap.q4 = idx;
                            if (cleanHeader.includes('facilitator score')) colMap.q5 = idx;
                            if (cleanHeader.includes('comment')) colMap.comment = idx;
                            if (cleanHeader.includes('start date')) colMap.startDate = idx;
                        }
                    });

                    const parsedData = dataRows
                        .filter(row => row && row.some(cell => cell !== null && cell !== ''))
                        .map(row => ({
                            startDate: row[colMap.startDate] ? new Date(row[colMap.startDate]) : new Date(),
                            department: row[colMap.department] || '',
                            session: row[colMap.session] || '',
                            contentRelevance: row[colMap.q3_1] || '',
                            durationAppropriate: row[colMap.q3_2] || '',
                            futureUsability: row[colMap.q3_3] || '',
                            trainingScore: parseFloat(row[colMap.q4]) || 0,
                            facilitatorScore: parseFloat(row[colMap.q5]) || 0,
                            comment: row[colMap.comment] || null
                        }))
                        .filter(d => d.department && d.session);

                    if (parsedData.length === 0) {
                        throw new Error('No valid data found in uploaded file');
                    }

                    allData = parsedData;
                    filteredData = [...allData];
                    updateFilterOptions();
                    renderDashboard();

                    statusDiv.textContent = `Successfully loaded ${parsedData.length} records!`;
                    statusDiv.style.color = '#28a745';

                    setTimeout(() => {
                        toggleUpload();
                        statusDiv.textContent = '';
                    }, 3000);

                } catch (error) {
                    statusDiv.textContent = `Error: ${error.message}`;
                    statusDiv.style.color = '#dc3545';
                    console.error('Upload error:', error);
                }
            };

            reader.onerror = function() {
                statusDiv.textContent = 'Error reading file';
                statusDiv.style.color = '#dc3545';
            };

            if (file.name.endsWith('.csv')) {
                reader.readAsText(file);
                reader.onload = function(e) {
                    try {
                        const csv = e.target.result;
                        const lines = csv.split('\n');
                        const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));

                        const parsedData = lines.slice(1)
                            .filter(line => line.trim())
                            .map(line => {
                                const values = line.split(',').map(v => v.trim().replace(/"/g, ''));
                                const obj = {};
                                headers.forEach((header, i) => {
                                    obj[header] = values[i];
                                });
                                return {
                                    startDate: new Date(obj['Start Date'] || obj['StartDate']),
                                    department: obj['Department'] || obj['Q1'],
                                    session: obj['Training Session'] || obj['Q2'],
                                    contentRelevance: obj['Content Relevance'] || obj['Q3_1'],
                                    durationAppropriate: obj['Duration Appropriate'] || obj['Q3_2'],
                                    futureUsability: obj['Future Usability'] || obj['Q3_3'],
                                    trainingScore: parseFloat(obj['Training Score (0-10)'] || obj['Q4_1_numeric']) || 0,
                                    facilitatorScore: parseFloat(obj['Facilitator Score (0-10)'] || obj['Q5_1_numeric']) || 0,
                                    comment: obj['Comments'] || obj['Q17'] || null
                                };
                            })
                            .filter(d => d.department && d.session);

                        allData = parsedData;
                        filteredData = [...allData];
                        updateFilterOptions();
                        renderDashboard();

                        statusDiv.textContent = `Successfully loaded ${parsedData.length} records!`;
                        statusDiv.style.color = '#28a745';

                        setTimeout(() => {
                            toggleUpload();
                            statusDiv.textContent = '';
                        }, 3000);
                    } catch (error) {
                        statusDiv.textContent = `Error: ${error.message}`;
                        statusDiv.style.color = '#dc3545';
                    }
                };
            } else {
                reader.readAsArrayBuffer(file);
            }
        }

        // Update filter dropdown options
        function updateFilterOptions() {
            const sessions = [...new Set(allData.map(d => d.session))].sort();
            const departments = [...new Set(allData.map(d => d.department))].sort();

            const sessionFilter = d3.select('#session-filter');
            sessionFilter.selectAll('option:not([value="all"])').remove();
            sessions.forEach(s => {
                sessionFilter.append('option').attr('value', s).text(s);
            });

            const deptFilter = d3.select('#department-filter');
            deptFilter.selectAll('option:not([value="all"])').remove();
            departments.forEach(d => {
                deptFilter.append('option').attr('value', d).text(d);
            });

            // Re-attach filter listeners (needed after upload)
            sessionFilter.on('change', updateFilters);
            deptFilter.on('change', updateFilters);
        }

        // Load and process data
        d3.csv('lds_survey_clean.csv').then(data => {
            allData = data.map(d => ({
                startDate: new Date(d.StartDate),
                endDate: new Date(d.EndDate),
                department: d.Q1,
                session: d.Q2,
                contentRelevance: d.Q3_1,
                durationAppropriate: d.Q3_2,
                futureUsability: d.Q3_3,
                trainingScore: +d.Q4_1_numeric,
                facilitatorScore: +d.Q5_1_numeric,
                trainingCategory: d.Q4_1_category,
                facilitatorCategory: d.Q5_1_category,
                comment: d.Q17
            }));

            filteredData = [...allData];

            const sessions = [...new Set(allData.map(d => d.session))].sort();
            const departments = [...new Set(allData.map(d => d.department))].sort();

            const sessionFilter = d3.select('#session-filter');
            sessions.forEach(s => {
                sessionFilter.append('option').attr('value', s).text(s);
            });

            const deptFilter = d3.select('#department-filter');
            departments.forEach(d => {
                deptFilter.append('option').attr('value', d).text(d);
            });

            sessionFilter.on('change', updateFilters);
            deptFilter.on('change', updateFilters);

            renderDashboard();
        });

        function updateFilters() {
            const sessionValue = d3.select('#session-filter').property('value');
            const deptValue = d3.select('#department-filter').property('value');

            filteredData = allData.filter(d => {
                const sessionMatch = sessionValue === 'all' || d.session === sessionValue;
                const deptMatch = deptValue === 'all' || d.department === deptValue;
                return sessionMatch && deptMatch;
            });

            renderDashboard();
        }

        function renderDashboard() {
            renderKPIs();
            renderKeyTakeaways();
            renderSessionComparison();
            renderDepartmentChart();
            renderNPSDistribution();
            renderLikertChart();
            renderComments();

            // Update header meta
            const sessions = [...new Set(filteredData.map(d => d.session))];
            d3.select('#header-meta').text(
                `${filteredData.length} responses across ${sessions.length} session${sessions.length !== 1 ? 's' : ''} | Notre Dame Research`
            );
        }

        function calculateNPS(scores) {
            const validScores = scores.filter(s => !isNaN(s));
            if (validScores.length === 0) return 0;
            const promoters = validScores.filter(s => s >= 9).length;
            const detractors = validScores.filter(s => s <= 6).length;
            return ((promoters - detractors) / validScores.length) * 100;
        }

        function renderKPIs() {
            const container = d3.select('#kpi-container');
            container.html('');

            const trainingScores = filteredData.map(d => d.trainingScore).filter(s => !isNaN(s));
            const facilitatorScores = filteredData.map(d => d.facilitatorScore).filter(s => !isNaN(s));
            const commentsCount = filteredData.filter(d => d.comment && d.comment !== 'NaN').length;

            const trainingNPS = calculateNPS(trainingScores);
            const facilitatorNPS = calculateNPS(facilitatorScores);
            const trainingLabel = npsLabel(trainingNPS);
            const facilitatorLabel = npsLabel(facilitatorNPS);

            const kpis = [
                {
                    label: 'Total Participants',
                    value: filteredData.length,
                    subtitle: 'Responses collected',
                    cardClass: '',
                    badge: null
                },
                {
                    label: 'Training NPS',
                    value: trainingNPS.toFixed(1),
                    subtitle: `Avg Score: ${(d3.mean(trainingScores) || 0).toFixed(1)}/10`,
                    cardClass: `nps-${trainingLabel.cls}`,
                    badge: trainingLabel
                },
                {
                    label: 'Facilitator NPS',
                    value: facilitatorNPS.toFixed(1),
                    subtitle: `Avg Score: ${(d3.mean(facilitatorScores) || 0).toFixed(1)}/10`,
                    cardClass: `nps-${facilitatorLabel.cls}`,
                    badge: facilitatorLabel
                },
                {
                    label: 'Comment Rate',
                    value: filteredData.length > 0 ? `${((commentsCount / filteredData.length) * 100).toFixed(0)}%` : '0%',
                    subtitle: `${commentsCount} of ${filteredData.length} left feedback`,
                    cardClass: '',
                    badge: null
                }
            ];

            const cards = container.selectAll('.kpi-card')
                .data(kpis)
                .enter()
                .append('div')
                .attr('class', d => `kpi-card ${d.cardClass}`);

            cards.append('div')
                .attr('class', 'kpi-label')
                .text(d => d.label);

            cards.append('div')
                .attr('class', 'kpi-value')
                .text(d => d.value);

            cards.append('div')
                .attr('class', 'kpi-subtitle')
                .text(d => d.subtitle);

            cards.filter(d => d.badge)
                .append('div')
                .attr('class', d => `kpi-badge badge-${d.badge.cls}`)
                .text(d => d.badge.text);
        }

        function renderKeyTakeaways() {
            const container = d3.select('#takeaways-content');
            container.html('');

            if (filteredData.length === 0) {
                container.append('div').attr('class', 'takeaway-item')
                    .html('<span style="color: #7f8c8d; font-style: italic;">No data available for selected filters.</span>');
                return;
            }

            const trainingScores = filteredData.map(d => d.trainingScore).filter(s => !isNaN(s));
            const facilitatorScores = filteredData.map(d => d.facilitatorScore).filter(s => !isNaN(s));
            const trainingNPS = calculateNPS(trainingScores);
            const facilitatorNPS = calculateNPS(facilitatorScores);
            const avgTraining = d3.mean(trainingScores) || 0;
            const avgFacilitator = d3.mean(facilitatorScores) || 0;

            // Highest/lowest session
            const sessionData = d3.group(filteredData, d => d.session);
            const sessionAvgs = Array.from(sessionData.entries()).map(([session, records]) => ({
                session,
                avg: d3.mean(records.map(d => d.trainingScore).filter(s => !isNaN(s))) || 0
            }));
            sessionAvgs.sort((a, b) => b.avg - a.avg);

            // Likert agreement
            const agreeCount = filteredData.filter(d => d.contentRelevance === 'Agree').length;
            const agreePct = filteredData.length > 0 ? ((agreeCount / filteredData.length) * 100).toFixed(0) : 0;

            // Promoters/detractors
            const promoters = trainingScores.filter(s => s >= 9).length;
            const promoterPct = trainingScores.length > 0 ? ((promoters / trainingScores.length) * 100).toFixed(0) : 0;

            const takeaways = [];

            // Overall NPS
            const tLabel = npsLabel(trainingNPS);
            const iconCls = tLabel.cls === 'excellent' ? 'icon-green' : tLabel.cls === 'good' ? 'icon-gold' : 'icon-red';
            takeaways.push({
                icon: iconCls,
                symbol: tLabel.cls === 'excellent' ? '+' : tLabel.cls === 'good' ? '~' : '!',
                text: `Overall Training NPS is <strong>${trainingNPS.toFixed(0)}</strong> (${tLabel.text}) with an average score of <strong>${avgTraining.toFixed(1)}/10</strong>. ${promoterPct}% of participants are promoters (scored 9-10).`
            });

            // Best session
            if (sessionAvgs.length > 1) {
                const best = sessionAvgs[0];
                const worst = sessionAvgs[sessionAvgs.length - 1];
                const bestShort = best.session.length > 40 ? best.session.substring(0, 40) + '...' : best.session;
                const worstShort = worst.session.length > 40 ? worst.session.substring(0, 40) + '...' : worst.session;
                takeaways.push({
                    icon: 'icon-blue',
                    symbol: '#',
                    text: `Highest rated session: <strong>${bestShort}</strong> (avg ${best.avg.toFixed(1)}). Lowest: <strong>${worstShort}</strong> (avg ${worst.avg.toFixed(1)}).`
                });
            }

            // Likert
            takeaways.push({
                icon: 'icon-green',
                symbol: '=',
                text: `<strong>${agreePct}%</strong> of participants fully agreed that training content was relevant. Facilitator average score: <strong>${avgFacilitator.toFixed(1)}/10</strong>.`
            });

            // Comments
            const commentsCount = filteredData.filter(d => d.comment && d.comment !== 'NaN').length;
            if (commentsCount > 0) {
                takeaways.push({
                    icon: 'icon-gold',
                    symbol: '"',
                    text: `<strong>${commentsCount}</strong> participant${commentsCount !== 1 ? 's' : ''} left written feedback (${((commentsCount / filteredData.length) * 100).toFixed(0)}% comment rate). Review comments below for qualitative insights.`
                });
            }

            takeaways.forEach(t => {
                container.append('div')
                    .attr('class', 'takeaway-item')
                    .html(`<div class="takeaway-icon ${t.icon}">${t.symbol}</div><div>${t.text}</div>`);
            });
        }

        function renderSessionComparison() {
            const container = d3.select('#session-comparison');
            container.html('');

            const sessionData = d3.group(filteredData, d => d.session);
            const sessions = Array.from(sessionData.keys()).sort();

            const data = sessions.map(session => {
                const records = sessionData.get(session);
                const trainingScores = records.map(d => d.trainingScore).filter(s => !isNaN(s));
                const facilitatorScores = records.map(d => d.facilitatorScore).filter(s => !isNaN(s));

                return {
                    session: session,
                    trainingAvg: d3.mean(trainingScores) || 0,
                    facilitatorAvg: d3.mean(facilitatorScores) || 0,
                    trainingNPS: calculateNPS(trainingScores),
                    facilitatorNPS: calculateNPS(facilitatorScores),
                    count: records.length
                };
            });

            const longestLabel = sessions.length > 0 ? Math.max(...sessions.map(s => Math.min(s.length, 35))) : 20;
            const bottomMargin = Math.min(180, Math.max(100, longestLabel * 4));
            const margin = {top: 40, right: 120, bottom: bottomMargin, left: 60};
            const width = 900 - margin.left - margin.right;
            const height = 400 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .style('overflow', 'visible')
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const x0 = d3.scaleBand()
                .domain(sessions)
                .range([0, width])
                .padding(0.3);

            const x1 = d3.scaleBand()
                .domain(['training', 'facilitator'])
                .range([0, x0.bandwidth()])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, 10])
                .range([height, 0]);

            svg.append('g')
                .attr('class', 'grid')
                .selectAll('line')
                .data(y.ticks(5))
                .enter()
                .append('line')
                .attr('class', 'gridline')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', d => y(d))
                .attr('y2', d => y(d));

            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x0).tickFormat(d => d.length > 35 ? d.substring(0, 35) + '...' : d))
                .selectAll('text')
                .attr('transform', 'rotate(-30)')
                .style('text-anchor', 'end')
                .attr('dx', '-0.5em')
                .attr('dy', '0.5em')
                .style('font-size', '11px');

            svg.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y));

            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -45)
                .attr('x', -height / 2)
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .style('fill', '#5a6c7d')
                .text('Average Score (0-10)');

            const sessionGroups = svg.selectAll('.session-group')
                .data(data)
                .enter()
                .append('g')
                .attr('transform', d => `translate(${x0(d.session)},0)`);

            sessionGroups.append('rect')
                .attr('class', 'bar')
                .attr('x', x1('training'))
                .attr('y', d => y(d.trainingAvg))
                .attr('width', x1.bandwidth())
                .attr('height', d => height - y(d.trainingAvg))
                .attr('fill', colors.blue)
                .on('mouseover', function(event, d) {
                    showTooltip(event, `
                        <strong>Training Recommendation</strong><br/>
                        Session: ${d.session}<br/>
                        Avg Score: ${d.trainingAvg.toFixed(2)}/10<br/>
                        NPS: ${d.trainingNPS.toFixed(1)}<br/>
                        Responses: ${d.count}
                    `);
                })
                .on('mouseout', hideTooltip);

            sessionGroups.append('text')
                .attr('x', x1('training') + x1.bandwidth() / 2)
                .attr('y', d => y(d.trainingAvg) - 5)
                .attr('text-anchor', 'middle')
                .attr('font-size', '12px')
                .attr('font-weight', 'bold')
                .attr('fill', colors.blue)
                .text(d => d.trainingAvg.toFixed(1));

            sessionGroups.append('rect')
                .attr('class', 'bar')
                .attr('x', x1('facilitator'))
                .attr('y', d => y(d.facilitatorAvg))
                .attr('width', x1.bandwidth())
                .attr('height', d => height - y(d.facilitatorAvg))
                .attr('fill', colors.purple)
                .on('mouseover', function(event, d) {
                    showTooltip(event, `
                        <strong>Facilitator Recommendation</strong><br/>
                        Session: ${d.session}<br/>
                        Avg Score: ${d.facilitatorAvg.toFixed(2)}/10<br/>
                        NPS: ${d.facilitatorNPS.toFixed(1)}<br/>
                        Responses: ${d.count}
                    `);
                })
                .on('mouseout', hideTooltip);

            sessionGroups.append('text')
                .attr('x', x1('facilitator') + x1.bandwidth() / 2)
                .attr('y', d => y(d.facilitatorAvg) - 5)
                .attr('text-anchor', 'middle')
                .attr('font-size', '12px')
                .attr('font-weight', 'bold')
                .attr('fill', colors.purple)
                .text(d => d.facilitatorAvg.toFixed(1));

            const legend = container.append('div')
                .attr('class', 'legend');

            legend.append('div')
                .attr('class', 'legend-item')
                .html(`<div class="legend-color" style="background: ${colors.blue}"></div><span>Training Recommendation</span>`);

            legend.append('div')
                .attr('class', 'legend-item')
                .html(`<div class="legend-color" style="background: ${colors.purple}"></div><span>Facilitator Recommendation</span>`);

            // Insight
            if (data.length > 0) {
                data.sort((a, b) => b.trainingAvg - a.trainingAvg);
                const best = data[0];
                const worst = data[data.length - 1];
                const bestShort = best.session.length > 45 ? best.session.substring(0, 45) + '...' : best.session;
                let insightText = `<strong>Highest rated:</strong> ${bestShort} (${best.trainingAvg.toFixed(1)} avg training, ${best.facilitatorAvg.toFixed(1)} avg facilitator, n=${best.count}).`;
                if (data.length > 1) {
                    const worstShort = worst.session.length > 45 ? worst.session.substring(0, 45) + '...' : worst.session;
                    insightText += ` <strong>Lowest rated:</strong> ${worstShort} (${worst.trainingAvg.toFixed(1)} avg training, n=${worst.count}).`;
                }
                d3.select('#insight-session').html(insightText);
            }
        }

        function renderDepartmentChart() {
            const container = d3.select('#department-chart');
            container.html('');

            const deptCounts = d3.rollup(filteredData, v => v.length, d => d.department);
            const data = Array.from(deptCounts, ([dept, count]) => ({dept, count}));
            data.sort((a, b) => b.count - a.count);

            const width = 400;
            const height = 300;
            const radius = Math.min(width, height) / 2 - 40;

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height)
                .append('g')
                .attr('transform', `translate(${width / 2},${height / 2})`);

            const color = d3.scaleOrdinal()
                .domain(data.map(d => d.dept))
                .range([colors.primary, colors.secondary, colors.blue, colors.purple, colors.teal]);

            const pie = d3.pie()
                .value(d => d.count)
                .sort(null);

            const arc = d3.arc()
                .innerRadius(radius * 0.5)
                .outerRadius(radius);

            const arcs = svg.selectAll('arc')
                .data(pie(data))
                .enter()
                .append('g');

            arcs.append('path')
                .attr('d', arc)
                .attr('fill', d => color(d.data.dept))
                .attr('stroke', 'white')
                .attr('stroke-width', 2)
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    d3.select(this).style('opacity', 0.8);
                    showTooltip(event, `
                        <strong>${d.data.dept}</strong><br/>
                        Responses: ${d.data.count}<br/>
                        Percentage: ${((d.data.count / filteredData.length) * 100).toFixed(1)}%
                    `);
                })
                .on('mouseout', function() {
                    d3.select(this).style('opacity', 1);
                    hideTooltip();
                });

            arcs.append('text')
                .attr('transform', d => `translate(${arc.centroid(d)})`)
                .attr('text-anchor', 'middle')
                .attr('fill', 'white')
                .attr('font-weight', 'bold')
                .attr('font-size', '14px')
                .text(d => `${d.data.dept}\n${d.data.count}`);

            const legend = container.append('div')
                .attr('class', 'legend')
                .style('margin-top', '20px')
                .style('justify-content', 'center');

            data.forEach(d => {
                legend.append('div')
                    .attr('class', 'legend-item')
                    .html(`<div class="legend-color" style="background: ${color(d.dept)}"></div><span>${d.dept}: ${d.count} (${((d.count / filteredData.length) * 100).toFixed(1)}%)</span>`);
            });

            // Insight
            if (data.length > 0) {
                const top = data[0];
                const topPct = ((top.count / filteredData.length) * 100).toFixed(0);
                let insightText = `<strong>${top.dept}</strong> had the most responses with ${top.count} (${topPct}%).`;
                if (data.length > 1) {
                    const bottom = data[data.length - 1];
                    const bottomPct = ((bottom.count / filteredData.length) * 100).toFixed(0);
                    insightText += ` <strong>${bottom.dept}</strong> had the fewest with ${bottom.count} (${bottomPct}%).`;
                }
                d3.select('#insight-department').html(insightText);
            }
        }

        function renderNPSDistribution() {
            const container = d3.select('#nps-distribution');
            container.html('');

            d3.select('#nps-title').text(`NPS Score Distribution (n=${filteredData.length})`);

            const scores = [];
            for (let i = 0; i <= 10; i++) {
                const trainingCount = filteredData.filter(d => Math.round(d.trainingScore) === i).length;
                const facilitatorCount = filteredData.filter(d => Math.round(d.facilitatorScore) === i).length;
                scores.push({
                    score: i,
                    training: trainingCount,
                    facilitator: facilitatorCount
                });
            }

            const margin = {top: 20, right: 100, bottom: 50, left: 50};
            const width = 500 - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const x = d3.scaleBand()
                .domain(scores.map(d => d.score))
                .range([0, width])
                .padding(0.2);

            const y = d3.scaleLinear()
                .domain([0, d3.max(scores, d => Math.max(d.training, d.facilitator)) || 1])
                .range([height, 0]);

            const x1 = d3.scaleBand()
                .domain(['training', 'facilitator'])
                .range([0, x.bandwidth()])
                .padding(0.05);

            svg.append('g')
                .attr('class', 'grid')
                .selectAll('line')
                .data(y.ticks(5))
                .enter()
                .append('line')
                .attr('class', 'gridline')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', d => y(d))
                .attr('y2', d => y(d));

            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x));

            svg.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y).ticks(5));

            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height + 40)
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .style('fill', '#5a6c7d')
                .text('Score (0-10)');

            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -40)
                .attr('x', -height / 2)
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .style('fill', '#5a6c7d')
                .text('Frequency');

            const scoreGroups = svg.selectAll('.score-group')
                .data(scores)
                .enter()
                .append('g')
                .attr('transform', d => `translate(${x(d.score)},0)`);

            scoreGroups.append('rect')
                .attr('x', x1('training'))
                .attr('y', d => y(d.training))
                .attr('width', x1.bandwidth())
                .attr('height', d => height - y(d.training))
                .attr('fill', colors.blue)
                .on('mouseover', function(event, d) {
                    showTooltip(event, `<strong>Training Score: ${d.score}</strong><br/>Count: ${d.training}`);
                })
                .on('mouseout', hideTooltip);

            scoreGroups.append('rect')
                .attr('x', x1('facilitator'))
                .attr('y', d => y(d.facilitator))
                .attr('width', x1.bandwidth())
                .attr('height', d => height - y(d.facilitator))
                .attr('fill', colors.purple)
                .on('mouseover', function(event, d) {
                    showTooltip(event, `<strong>Facilitator Score: ${d.score}</strong><br/>Count: ${d.facilitator}`);
                })
                .on('mouseout', hideTooltip);

            const legend = container.append('div')
                .attr('class', 'legend');

            legend.append('div')
                .attr('class', 'legend-item')
                .html(`<div class="legend-color" style="background: ${colors.blue}"></div><span>Training</span>`);

            legend.append('div')
                .attr('class', 'legend-item')
                .html(`<div class="legend-color" style="background: ${colors.purple}"></div><span>Facilitator</span>`);

            // Insight
            const trainingScores = filteredData.map(d => d.trainingScore).filter(s => !isNaN(s));
            const promoters = trainingScores.filter(s => s >= 9).length;
            const passives = trainingScores.filter(s => s >= 7 && s <= 8).length;
            const detractors = trainingScores.filter(s => s <= 6).length;
            const total = trainingScores.length || 1;
            d3.select('#insight-nps').html(
                `<strong>Training scores:</strong> ${((promoters/total)*100).toFixed(0)}% Promoters (9-10), ` +
                `${((passives/total)*100).toFixed(0)}% Passives (7-8), ` +
                `${((detractors/total)*100).toFixed(0)}% Detractors (0-6).`
            );
        }

        function renderLikertChart() {
            const container = d3.select('#likert-chart');
            container.html('');

            const questions = [
                { key: 'contentRelevance', label: 'Content Relevance' },
                { key: 'durationAppropriate', label: 'Duration Appropriate' },
                { key: 'futureUsability', label: 'Future Usability' }
            ];

            const responses = ['Agree', 'Tend to agree', 'Neither', 'Tend to disagree', 'Disagree'];

            const data = questions.map(q => {
                const counts = {};
                responses.forEach(r => {
                    counts[r] = filteredData.filter(d => d[q.key] === r).length;
                });
                const total = Object.values(counts).reduce((a, b) => a + b, 0);
                const percentages = {};
                responses.forEach(r => {
                    percentages[r] = total > 0 ? (counts[r] / total) * 100 : 0;
                });
                return { question: q.label, counts, percentages, total };
            });

            const margin = {top: 20, right: 150, bottom: 50, left: 200};
            const width = 900 - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const y = d3.scaleBand()
                .domain(data.map(d => d.question))
                .range([0, height])
                .padding(0.2);

            const x = d3.scaleLinear()
                .domain([0, 100])
                .range([0, width]);

            svg.append('g')
                .attr('class', 'axis')
                .call(d3.axisLeft(y));

            svg.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).ticks(5).tickFormat(d => d + '%'));

            data.forEach(d => {
                let xOffset = 0;
                responses.forEach(response => {
                    const pct = d.percentages[response];
                    if (pct > 0) {
                        svg.append('rect')
                            .attr('x', x(xOffset))
                            .attr('y', y(d.question))
                            .attr('width', x(pct))
                            .attr('height', y.bandwidth())
                            .attr('fill', colors.likert[response])
                            .on('mouseover', function(event) {
                                showTooltip(event, `
                                    <strong>${d.question}</strong><br/>
                                    ${response}: ${d.counts[response]} (${pct.toFixed(1)}%)
                                `);
                            })
                            .on('mouseout', hideTooltip);

                        if (pct > 8) {
                            svg.append('text')
                                .attr('x', x(xOffset + pct / 2))
                                .attr('y', y(d.question) + y.bandwidth() / 2)
                                .attr('text-anchor', 'middle')
                                .attr('dominant-baseline', 'middle')
                                .attr('fill', 'white')
                                .attr('font-size', '11px')
                                .attr('font-weight', 'bold')
                                .text(`${pct.toFixed(0)}%`);
                        }

                        xOffset += pct;
                    }
                });
            });

            const legend = container.append('div')
                .attr('class', 'legend');

            responses.forEach(r => {
                legend.append('div')
                    .attr('class', 'legend-item')
                    .html(`<div class="legend-color" style="background: ${colors.likert[r]}"></div><span>${r}</span>`);
            });

            // Insight
            const bestMetric = data.reduce((best, d) => (d.percentages['Agree'] || 0) > (best.percentages['Agree'] || 0) ? d : best, data[0]);
            const worstMetric = data.reduce((worst, d) => (d.percentages['Agree'] || 0) < (worst.percentages['Agree'] || 0) ? d : worst, data[0]);
            let insightText = `<strong>${bestMetric.question}</strong> had the highest full agreement at ${(bestMetric.percentages['Agree'] || 0).toFixed(0)}%.`;
            if (bestMetric.question !== worstMetric.question) {
                insightText += ` <strong>${worstMetric.question}</strong> had the lowest at ${(worstMetric.percentages['Agree'] || 0).toFixed(0)}%.`;
            }
            d3.select('#insight-likert').html(insightText);
        }

        function renderComments() {
            const container = d3.select('#comments-container');
            container.html('');

            const commentsData = filteredData
                .filter(d => d.comment && d.comment !== 'NaN')
                .map(d => ({
                    date: d.startDate.toLocaleDateString(),
                    session: d.session,
                    department: d.department,
                    trainingScore: d.trainingScore,
                    facilitatorScore: d.facilitatorScore,
                    comment: d.comment
                }))
                .sort((a, b) => new Date(b.date) - new Date(a.date));

            if (commentsData.length === 0) {
                container.append('p')
                    .style('color', '#7f8c8d')
                    .style('font-style', 'italic')
                    .text('No comments available for the selected filters.');
                return;
            }

            const table = container.append('table')
                .attr('class', 'comment-table');

            const thead = table.append('thead');
            const tbody = table.append('tbody');

            thead.append('tr')
                .selectAll('th')
                .data(['Date', 'Session', 'Dept', 'Training', 'Facilitator', 'Comment'])
                .enter()
                .append('th')
                .text(d => d);

            const rows = tbody.selectAll('tr')
                .data(commentsData)
                .enter()
                .append('tr');

            rows.append('td').text(d => d.date);
            rows.append('td')
                .style('font-size', '0.85em')
                .text(d => d.session.substring(0, 30) + (d.session.length > 30 ? '...' : ''));
            rows.append('td').text(d => d.department);
            rows.append('td').html(d => {
                const score = d.trainingScore;
                const className = score >= 9 ? 'score-high' : score >= 7 ? 'score-mid' : 'score-low';
                return `<span class="score-badge ${className}">${score}</span>`;
            });
            rows.append('td').html(d => {
                const score = d.facilitatorScore;
                const className = score >= 9 ? 'score-high' : score >= 7 ? 'score-mid' : 'score-low';
                return `<span class="score-badge ${className}">${score}</span>`;
            });
            rows.append('td')
                .attr('class', 'comment-text')
                .text(d => d.comment);
        }

        function showTooltip(event, html) {
            const tooltip = d3.select('#tooltip');
            tooltip.html(html)
                .classed('show', true)
                .style('left', (event.pageX + 15) + 'px')
                .style('top', (event.pageY - 10) + 'px');
        }

        function hideTooltip() {
            d3.select('#tooltip').classed('show', false);
        }
    </script>
</body>
</html>
